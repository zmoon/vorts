<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vorts.model API documentation</title>
<meta name="description" content="Model classes that act as drivers for the integration routines,
directing input and collecting output, etc." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!-- MathJax 3, with $..$ for inline math enabled -->
<script>
MathJax = {
tex: {
inlineMath: [['$', '$'], ['\\(', '\\)']]
},
svg: {
fontCache: 'global'
}
};
</script>
<script type="text/javascript" id="MathJax-script" async
src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vorts.model</code></h1>
</header>
<section id="section-intro">
<p>Model classes that act as drivers for the integration routines,
directing input and collecting output, etc.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/f26dc94d4ed5ba1d53a2199bbcef82fa9cd4cece/vorts/model.py#L0-L644" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Model classes that act as drivers for the integration routines,
directing input and collecting output, etc.
&#34;&#34;&#34;
import abc
import contextlib
import copy
import glob
import os
import platform
import subprocess
import warnings
from pathlib import Path

import numpy as np
import xarray as xr

from .plot import plot_poincare, plot_tracer_trajectories, plot_vorton_trajectories
from .py import MANUAL_STEPPERS, SCIPY_METHODS, integrate_manual, integrate_scipy
from .vortons import Tracers, Vortons


class ModelBase(abc.ABC):
    &#34;&#34;&#34;Abstract base class for the models.

    Provides concrete methods `ModelBase.run` and `ModelBase.plot`, which work properly if the
    inheriting class defines a `_run` method that integrates the system and updates `ModelBase.hist`,
    populating it with the run&#39;s output data.
    &#34;&#34;&#34;

    def __init__(
        self,
        vortons: Vortons = None,
        tracers: Tracers = None,
        *,
        dt=0.1,
        nt=1000,
    ):
        &#34;&#34;&#34;
        * `vortons` default to equilateral triangle (`vorts.vortons.Vortons.regular_polygon` with `3, G=1`)
        * `tracers` default to `None` (no tracers used)
        &#34;&#34;&#34;
        # vortons (default to equilateral triangle)
        if vortons is None:
            vortons = Vortons.regular_polygon(3, G=1)
        self.vortons = vortons
        &#34;&#34;&#34;`vorts.vortons.Vortons` for the model instance.&#34;&#34;&#34;
        self.vortons0 = copy.deepcopy(vortons)  # store initial state (in hist as well)
        &#34;&#34;&#34;A copy of the initial `vorts.vortons.Vortons`, corresponding to the model input.&#34;&#34;&#34;

        # tracers (leave if `None`)
        self.tracers = tracers
        &#34;&#34;&#34;`vorts.vortons.Tracers` for the model instance, or `None` if no tracers.&#34;&#34;&#34;
        self.tracers0 = copy.deepcopy(self.tracers)
        &#34;&#34;&#34;A copy of the initial `vorts.vortons.Tracers` for the model instance, or `None` if no tracers.&#34;&#34;&#34;

        # sim settings/parameters for every model
        self.dt = float(dt)
        r&#34;&#34;&#34;Time step $\delta t$ for the model output.&#34;&#34;&#34;
        self.nt = int(nt)
        &#34;&#34;&#34;The number of time steps to run for, such that `t=nt*dt` is the last time simulated
        and we have a total of `nt+1` times when including the initial state.
        &#34;&#34;&#34;
        self.n_tracers = self.tracers0.n if self.tracers0 is not None else 0
        &#34;&#34;&#34;The number of tracers.&#34;&#34;&#34;
        self.n_vortons = self.vortons0.n
        &#34;&#34;&#34;The number of vortons (tracers not included!).&#34;&#34;&#34;
        self.n_points = self.n_vortons + self.n_tracers
        &#34;&#34;&#34;The number of vortons + tracers.&#34;&#34;&#34;
        self.n_timesteps = self.nt
        &#34;&#34;&#34;Alias for `ModelBase.nt`.&#34;&#34;&#34;

        # combine vortons and tracers (used by some models to feed combined initial states to integrators)
        self._vt0 = self.vortons0._maybe_add_tracers(self.tracers0)

        # initially no history
        self.hist = None
        &#34;&#34;&#34;An [`xr.Dataset`](http://xarray.pydata.org/en/stable/generated/xarray.Dataset.html)
        with coordinates `&#39;t&#39;` (time) and `&#39;v&#39;` (vorton index, including any tracers).
        Equal to `None` before the model has run.
        &#34;&#34;&#34;

        # initially, the model hasn&#39;t been run
        self._has_run = False

    @abc.abstractmethod
    def _run(self):
        &#34;&#34;&#34;The `_run` method in concrete classes should:

        1. Integrate the system from t=0 -&gt; t=(nt*dt).

        2. Update `hist`.
        &#34;&#34;&#34;
        ...

    def run(self):
        &#34;&#34;&#34;Integrate and update the history dataset `hist`.&#34;&#34;&#34;
        if self._has_run:
            warnings.warn(&#34;Note that the model has already been run.&#34;)
        self._run()
        self._has_run = True
        # TODO: with hist having been updated (presumably), update vortons?

        return self

    # might be better to use _plot_methods dict of name: function
    # so that certain models could extend the options
    def plot(self, which=&#34;vortons&#34;, **kwargs):
        &#34;&#34;&#34;Plot results stored in the history data set `hist`.

        `**kwargs` are passed through to the corresponding plotting function
        (see `vorts.plot`).
        &#34;&#34;&#34;
        if not self._has_run:
            raise Exception(&#34;The model has not yet been run.&#34;)

        if which == &#34;vortons&#34;:
            plot_vorton_trajectories(self.hist, **kwargs)
        elif which == &#34;tracers&#34;:
            plot_tracer_trajectories(self.hist, **kwargs)
        elif which == &#34;poincare&#34;:
            plot_poincare(self.hist, **kwargs)
        else:
            raise NotImplementedError(f&#34;which={which!r}&#34;)

    def _res_to_xr(self, xhist, yhist):
        &#34;&#34;&#34;Take full trajectory histories `xhist` and `yhist`
        in $(t, v)$ dim order and create a model results `xr.dataset`.
        &#34;&#34;&#34;
        vt0 = self._vt0

        G = vt0.G
        t = np.arange(0, self.nt + 1) * self.dt
        v = np.arange(0, vt0.n)

        is_t = G == 0

        ds = xr.Dataset(
            coords={
                &#34;t&#34;: (&#34;t&#34;, t, {&#34;long_name&#34;: &#34;Unitless elapsed time&#34;}),
                &#34;v&#34;: (
                    &#34;v&#34;,
                    v,
                    {
                        &#34;long_name&#34;: &#34;Vorton index&#34;,
                        &#34;description&#34;: (
                            r&#34;This includes true vortons (with nonzero $\Gamma$, coming first) &#34;
                            r&#34;and may also include tracers ($\Gamma = 0$, coming after).&#34;
                        ),
                    },
                ),
            },
            data_vars={
                &#34;G&#34;: ((&#34;v&#34;,), G, {&#34;long_name&#34;: r&#34;Vorton strength $\Gamma$ (circulation)&#34;}),
                &#34;x&#34;: ((&#34;t&#34;, &#34;v&#34;), xhist, {&#34;long_name&#34;: &#34;Vorton $x$ position&#34;}),
                &#34;y&#34;: ((&#34;t&#34;, &#34;v&#34;), yhist, {&#34;long_name&#34;: &#34;Vorton $y$ position&#34;}),
                &#34;is_t&#34;: (
                    (&#34;v&#34;,),
                    is_t,
                    {
                        &#34;long_name&#34;: &#34;Tracer mask&#34;,
                        &#34;description&#34;: (
                            r&#34;Vortons have nonzero $\Gamma$ values. Tracers have no $\Gamma$.&#34;
                        ),
                    },
                ),
            },
            attrs={
                &#34;model_class&#34;: self.__class__.__name__,
                &#34;int_scheme_name&#34;: getattr(self, &#34;int_scheme_name&#34;, &#34;?&#34;),
            },
        )
        return ds


class Model_py(ModelBase):
    &#34;&#34;&#34;Model in Python.&#34;&#34;&#34;

    _manual_steppers = MANUAL_STEPPERS
    _scipy_methods = SCIPY_METHODS
    _allowed_int_scheme_names = list(_manual_steppers) + list(_scipy_methods)
    # _allowed_int_scheme_names = list(_scipy_methods)  # temporarily disable manual steppers methods

    def __init__(
        self,
        vortons: Vortons = None,
        tracers: Tracers = None,
        *,
        dt=0.1,
        nt=1000,
        # above are passed to base
        int_scheme_name=&#34;RK4&#34;,
        **int_scheme_kwargs,
    ):
        r&#34;&#34;&#34;

        Parameters
        ----------
        vortons : vorts.vortons.Vortons
            default: equilateral triangle with inscribing circle radius of $1$ and all $G=1$.

        tracers : vorts.vortons.Tracers
            default: no tracers

        dt : float
            Time step $\delta t$ for the output.
            Additionally, for the integrators, `dt` is used as the constant or maximum integration time step
            depending on the integration scheme.
        nt : int
            Number of time steps to run (not including $t=0$).

        int_scheme_name : str
            Time integration scheme name.

            default: `&#39;RK4&#39;` -- handwritten standard RK4, using Numba to calculate the tendencies

            Other currently valid options are:

            * `&#39;scipy_*&#39;` methods -- use [`scipy.integrate.solve_ivp`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html)

                where the `*` can be `RK45`, `DOP854`, `Radau`, `BDF`, `LSODA`

            * `&#39;FT&#39;` -- handwritten 1st-order forward Euler

        **int_scheme_kwargs
            Passed on to `vorts.py.integ.integrate_manual` or `vorts.py.integ.integrate_scipy`.

        &#34;&#34;&#34;
        # call base initialization
        super().__init__(vortons, tracers, dt=dt, nt=nt)

        # other inputs
        self.int_scheme_name = int_scheme_name
        self.int_scheme_kwargs = int_scheme_kwargs

        # check `int_scheme_name`
        if self.int_scheme_name not in self._allowed_int_scheme_names:
            raise ValueError(
                f&#34;{self.int_scheme_name!r} is not one of the allowed options for `int_scheme_name`:\n&#34;
                f&#34;{self._allowed_int_scheme_names}&#34;
            )

        # calculate initial C, used for adaptive time stepping tolerance checks
        self.C_0 = self.vortons0.C()

    # implement abstract method `_run`
    def _run(self):
        dt, nt = self.dt, self.nt
        # t_eval = np.arange(dt, (nt+1)*dt, dt)
        t_eval = np.arange(0, nt + 1) * dt
        v0 = self._vt0

        # manual (handwritten) integrators
        if &#34;scipy&#34; not in self.int_scheme_name:
            x0 = v0.x
            y0 = v0.y
            G = v0.G
            xhist, yhist = integrate_manual(
                G,
                x0,
                y0,
                #
                self.C_0,
                t_eval,
                stepper=self._manual_steppers[self.int_scheme_name],
                **self.int_scheme_kwargs,
            )
            # returned data have shape (nv, nt)
            self.hist = self._res_to_xr(xhist.T, yhist.T)

        # integration using SciPy
        else:
            y0 = v0.xy.T.flatten()  # needs to be a 1-d array!
            G_col = v0.G_col
            data = integrate_scipy(
                y0,
                t_eval,
                G_col,
                #
                method=self._scipy_methods[self.int_scheme_name],
                max_step=dt,
                **self.int_scheme_kwargs,
            )
            # returned data has shape (2nv, nt), where n is number of vortons and nt number of time steps
            nv = v0.n
            self.hist = self._res_to_xr(data[:nv, :].T, data[nv:, :].T)


FORT_BASE_DIR = Path(__file__).parent / &#34;f&#34;  # .absolute()
# ^ the one that `bin`, `in`, `out`, `src` are in


def fort_bool(b: bool):
    &#34;&#34;&#34;Convert Python boolean to a string of the corresponding Fortran logical (`.true.`/`.false.`).&#34;&#34;&#34;
    return &#34;.true.&#34; if b else &#34;.false.&#34;


@contextlib.contextmanager
def _out_and_back(p):
    &#34;&#34;&#34;Context manager: change working directory to path `p` but return to original cwd after.&#34;&#34;&#34;
    # ref: https://stackoverflow.com/a/170174
    cwd = os.getcwd()
    os.chdir(p)
    try:
        yield
    finally:
        os.chdir(cwd)


class Model_f(ModelBase):
    &#34;&#34;&#34;Thin wrapper for functionality of the Fortran model, whose source code is in `vorts/f/src/`.

    .. note::
       In this implementation we communicate with the Fortran program via text files.
    &#34;&#34;&#34;

    # _allowed_int_scheme_names = (&#34;FT&#34;, &#34;RK4&#34;)

    def __init__(
        self,
        vortons: Vortons = None,
        tracers: Tracers = None,
        *,
        dt=0.1,
        nt=1000,
        # above are passed to base
        int_scheme_name=&#34;RK4&#34;,
        #
        write_vortons=True,  # maybe should put `flag` or something in these names
        write_tracers=False,
        write_ps=False,
    ):
        r&#34;&#34;&#34;

        Parameters
        ----------
        vortons : vorts.vortons.Vortons
            default: equilateral triangle with inscribing circle radius of $1$ and all $G=1$.

        tracers : vorts.vortons.Tracers
            default: no tracers

        dt : float
            Time step $\delta t$ for the output.
            Additionally, for the integrators, `dt` is used as the constant or maximum integration time step
            depending on the integration scheme.
        nt : int
            Number of time steps to run (not including $t=0$).

        int_scheme_name : str
            Time integration scheme name.

            options: `&#39;RK4&#39;` (standard RK4; default), `&#39;FT&#39;` (1st-order forward Euler)

        &#34;&#34;&#34;
        # call base initialization
        super().__init__(vortons, tracers, dt=dt, nt=nt)

        # other inputs
        self.int_scheme_name = int_scheme_name  # {&#39;FT&#39;, &#39;RK4&#39;}

        # output option flags
        self.f_write_out_vortons = write_vortons
        self.f_write_out_tracers = write_tracers
        self.f_write_out_ps = write_ps

        # executing the model
        assert (FORT_BASE_DIR / &#34;src&#34;).exists(), &#34;Fortran source directory not found!&#34;
        exe_name = &#34;vorts.exe&#34; if platform.system() == &#34;Windows&#34; else &#34;vorts&#34;
        self.vorts_exe_path = FORT_BASE_DIR / &#34;bin&#34; / exe_name
        self.oe = &#34;&#34;  # we will store standard output and error here

        # create the needed subdirs if they don&#39;t exist (pip install)
        for sub in (&#34;bin&#34;, &#34;in&#34;, &#34;out&#34;):
            p = FORT_BASE_DIR / sub
            if not p.exists():
                p.mkdir()

        # write the text input files to directory `vorts/f/in`
        self.create_inputs()

    def create_inputs(self):
        &#34;&#34;&#34;
        Create input files for the Fortran model
          describing the initial condition
          and the simulation settings.
        &#34;&#34;&#34;
        # # write vorton system initial state
        # mat = self.vortons0.state_mat_full()  # needs to be rows of G, xi, yi
        # np.savetxt(FORT_BASE_DIR / &#39;in/vorts_in.txt&#39;, mat,
        #            delimiter=&#39; &#39;, fmt=&#39;%.16f&#39;, header=&#39;Gamma xi yi&#39;)

        # # write tracers initial state (positions only)
        # mat = self.tracers0.state_mat
        # np.savetxt(FORT_BASE_DIR / &#39;in/tracers_in.txt&#39;, mat,
        #            delimiter=&#39; &#39;, fmt=&#39;%.16f&#39;, header=&#39;xi yi&#39;)

        # Write combined vortons + tracers, with vortons first
        mat = self._vt0.state_mat_full()
        np.savetxt(
            FORT_BASE_DIR / &#34;in/vortons.txt&#34;, mat, delimiter=&#34; &#34;, fmt=&#34;%.16f&#34;, header=&#34;Gamma xi yi&#34;
        )

        # write model options
        mat = [
            self.dt,
            self.nt,
            self.int_scheme_name,
            fort_bool(self.f_write_out_vortons),
            fort_bool(self.f_write_out_tracers),
            fort_bool(self.f_write_out_ps),
        ]
        np.savetxt(FORT_BASE_DIR / &#34;in/settings.txt&#34;, mat, delimiter=&#34; &#34;, fmt=&#34;%s&#34;)

    def _maybe_try_compile(self):
        &#34;&#34;&#34;Try to run `make` if the executable is missing.&#34;&#34;&#34;
        if not self.vorts_exe_path.exists():
            with _out_and_back(FORT_BASE_DIR / &#34;src&#34;):
                print(f&#34;{self.vorts_exe_path!r} doesn&#39;t exist, attempting to `make`.\n&#34;)
                try:
                    subprocess.run(&#34;make&#34;)
                except Exception as e:
                    raise Exception(
                        &#34;Attempted `make` failed with exception (see above). &#34;
                        &#34;The Fortran code must be compiled before running!&#34;
                    ) from e

    # implement abstract method `_run`
    def _run(self):
        &#34;&#34;&#34;Invoke the Fortran model&#39;s executable and load the results.&#34;&#34;&#34;
        self._maybe_try_compile()

        # Invoke the Fortran model&#39;s executable
        # Note: could instead pass FORT_BASE_DIR into the Fortran program so could run from anywhere
        cmd = str(self.vorts_exe_path.relative_to(FORT_BASE_DIR))
        with _out_and_back(FORT_BASE_DIR):
            for f in glob.glob(&#34;./out/*&#34;):  # non-hidden files
                os.remove(f)
            self.oe = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
            # Note: could instead use `error stop` in the Fortran to get non-zero exit code and `CalledProcessError`
            s_oe = str(self.oe, &#34;utf-8&#34;)
            if s_oe.startswith(&#34;STOP&#34;):
                raise Exception(f&#34;the model stopped early, with message:\n{str(s_oe)}&#34;)

        # Load results from the text file outputs into `self.hist` (an `xr.Dataset`)
        self._load_results()

    def _load_results(self):
        &#34;&#34;&#34;Load results from a run of the Fortran model.&#34;&#34;&#34;
        sf = 0  # there may be blank line at end of the files?

        nt = self.nt  # time steps taken
        nv = self._vt0.n
        G = self._vt0.G
        is_t = G == 0
        is_v = ~is_t

        # TODO: was trying avoid pre-allocating empty array, but for now gonna do it...
        self.hist = self._res_to_xr(np.empty((nt + 1, nv)), np.empty((nt + 1, nv)))

        if self.f_write_out_vortons:
            vortons_file = FORT_BASE_DIR / &#34;out/vortons.csv&#34;
            data = np.genfromtxt(vortons_file, delimiter=&#34;,&#34;, skip_header=1, skip_footer=sf)
            nrows = data.shape[0]
            i1 = np.arange(0, nrows - 1, 2)
            i2 = np.arange(1, nrows, 2)
            # need to swap dims because t is first in hist
            self.hist[&#34;x&#34;].loc[dict(v=is_v)] = data[i1, :].T
            self.hist[&#34;y&#34;].loc[dict(v=is_v)] = data[i2, :].T

        if self.f_write_out_tracers:
            tracers_file = FORT_BASE_DIR / &#34;out/tracers.csv&#34;
            data = np.genfromtxt(tracers_file, delimiter=&#34;,&#34;, skip_header=1, skip_footer=sf)
            nrows = data.shape[0]
            i1 = np.arange(0, nrows - 1, 2)
            i2 = np.arange(1, nrows, 2)
            self.hist[&#34;x&#34;].loc[dict(v=is_t)] = data[i1, :].T
            self.hist[&#34;y&#34;].loc[dict(v=is_t)] = data[i2, :].T

        # note: the ps code of the Fortran model only works for a specific case
        # (initial equi tri with the second point having x=0 and y&gt;0)
        if self.f_write_out_ps:
            ps_file = FORT_BASE_DIR / &#34;out/ps.txt&#34;
            data = np.genfromtxt(ps_file, skip_header=1, skip_footer=sf)
            self.ps = data


JL_BASE_DIR = Path(__file__).parent / &#34;jl&#34;


class Model_jl(ModelBase):
    &#34;&#34;&#34;Interface to the Julia model, whose source code is in `vorts/jl/vorts.jl`.

    .. note::
       In this implementation we communicate with Julia using
       [pyjulia](https://github.com/JuliaPy/pyjulia)
    &#34;&#34;&#34;

    def __init__(
        self,
        vortons: Vortons = None,
        tracers: Tracers = None,
        *,
        dt=0.1,
        nt=1000,
        # above are passed to base
        int_scheme_name=&#34;Tsit5&#34;,
        use_sysimage=False,
        run_method=&#34;pyjulia&#34;,
    ):
        r&#34;&#34;&#34;

        Parameters
        ----------
        vortons : vorts.vortons.Vortons
            default: equilateral triangle with inscribing circle radius of $1$ and all $G=1$.

        tracers : vorts.vortons.Tracers
            default: no tracers

        dt : float
            Time step $\delta t$ for the output.
            Additionally, for the integrators, `dt` is used as the constant or maximum integration time step
            depending on the integration scheme.
        nt : int
            Number of time steps to run (not including $t=0$).

        int_scheme_name : str
            Time integration scheme name. Any from the
            [ODE solvers list](https://diffeq.sciml.ai/stable/solvers/ode_solve/)
            are valid.
        use_sysimage : bool
            Whether to (try to) use the `sys_vorts.so` created by the `compile.jl` script.
        run_method : str, {&#39;pyjulia&#39;, &#39;diffeqpy&#39;}
            Currently, we can run using pyjulia alone or using diffeqpy.
            Both use the tendency function defined in `vorts.jl`.
        &#34;&#34;&#34;
        # Call base initialization
        super().__init__(vortons, tracers, dt=dt, nt=nt)

        # Other inputs
        self.int_scheme_name = int_scheme_name
        self.use_sysimage = use_sysimage
        self.run_method = run_method

    @staticmethod
    def _load_jl_sysimage():
        # Use our sysimage with DifferentialEquations (and our tend fn) pre-compiled
        # (has to be done before importing any Julia modules)
        from julia import Julia

        jl = Julia(sysimage=str(JL_BASE_DIR / &#34;sys_vorts.so&#34;))
        # TODO: might want to also support `Julia(compiled_modules=False)` in some way
        return jl

    # pyjulia alone
    def _run_pyjulia(self):
        from julia.core import JuliaError

        if self.use_sysimage:
            self._load_jl_sysimage()

        # For some reason it doesn&#39;t work the first time on Windows (can&#39;t find PyCall)
        # but will work if we just do it again...
        try:
            from julia import Base, Main, Pkg
        except JuliaError as e:
            warnings.warn(f&#34;Julia imports failed the first time with message:\n{e}&#34;)
            from julia import Base, Main, Pkg

        # Load our code
        # Base.println(&#34;Initial env status:&#34;)
        # Pkg.status()
        Pkg.activate(JL_BASE_DIR.as_posix())
        Pkg.status()
        Main.include((JL_BASE_DIR / &#34;vorts.jl&#34;).as_posix())
        Base.println(&#34;vorts.jl has been loaded!&#34;)

        # Run by calling `integrate` from `vorts.jl`
        x, y = Main.integrate(
            self._vt0.state_mat,
            self._vt0.G,
            self.dt,
            self.nt,
            int_scheme_name=self.int_scheme_name,
            ret_for=&#34;python&#34;,
        )

        # Set output dataset
        self.hist = self._res_to_xr(x, y)

    # pyjulia + diffeqpy
    def _run_diffeqpy(self):
        from julia.core import JuliaError

        if self.use_sysimage:
            self._load_jl_sysimage()

        try:
            from julia import Base, Main, Pkg
        except JuliaError as e:
            warnings.warn(f&#34;Julia imports failed the first time with message:\n{e}&#34;)
            from julia import Base, Main, Pkg

        Pkg.activate(JL_BASE_DIR.as_posix())
        Pkg.status()

        # `ode` from the readme doesn&#39;t work yet in stable (would have to install from GH)
        # This one would also take two tries in Win if we hadn&#39;t already done the above import
        from diffeqpy import de

        # Add the code with the tendency function
        Main.include((JL_BASE_DIR / &#34;vorts.jl&#34;).as_posix())
        Base.println(&#34;vorts.jl has been loaded!&#34;)

        # Set up our inputs
        nt = self.nt
        dt = self.dt
        vt0 = self._vt0
        r0 = vt0.state_mat.T  # note transpose!
        tspan = (0, dt * nt)
        p = Main.TendParams(vt0.G)
        solver = getattr(de, self.int_scheme_name)()

        prob = de.ODEProblem(Main.tend_b, r0, tspan, p)
        sol = de.solve(prob, solver, saveat=np.arange(0, nt + 1) * dt)

        # Exract data and set the output dataset
        x = np.empty((self.nt + 1, vt0.n))
        y = np.empty_like(x)
        assert len(sol.u) == nt + 1
        assert sol.u[0].shape == (2, vt0.n)
        for i in range(len(sol.u)):
            x[i, :] = sol.u[i][0, :]
            y[i, :] = sol.u[i][1, :]

        self.hist = self._res_to_xr(x, y)

    def _run(self):
        if self.run_method == &#34;pyjulia&#34;:
            self._run_pyjulia()
        elif self.run_method == &#34;diffeqpy&#34;:
            self._run_diffeqpy()
        else:
            raise ValueError(&#34;`run_method` must be &#39;pyjulia&#39; or &#39;diffeqpy&#39;.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vorts.model.fort_bool"><code class="name flex">
<span>def <span class="ident">fort_bool</span></span>(<span>b: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert Python boolean to a string of the corresponding Fortran logical (<code>.true.</code>/<code>.false.</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/f26dc94d4ed5ba1d53a2199bbcef82fa9cd4cece/vorts/model.py#L293-L295" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fort_bool(b: bool):
    &#34;&#34;&#34;Convert Python boolean to a string of the corresponding Fortran logical (`.true.`/`.false.`).&#34;&#34;&#34;
    return &#34;.true.&#34; if b else &#34;.false.&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vorts.model.ModelBase"><code class="flex name class">
<span>class <span class="ident">ModelBase</span></span>
<span>(</span><span>vortons: <a title="vorts.vortons.Vortons" href="vortons.html#vorts.vortons.Vortons">Vortons</a> = None, tracers: <a title="vorts.vortons.Tracers" href="vortons.html#vorts.vortons.Tracers">Tracers</a> = None, *, dt=0.1, nt=1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for the models.</p>
<p>Provides concrete methods <code><a title="vorts.model.ModelBase.run" href="#vorts.model.ModelBase.run">ModelBase.run()</a></code> and <code><a title="vorts.model.ModelBase.plot" href="#vorts.model.ModelBase.plot">ModelBase.plot()</a></code>, which work properly if the
inheriting class defines a <code>_run</code> method that integrates the system and updates <code><a title="vorts.model.ModelBase.hist" href="#vorts.model.ModelBase.hist">ModelBase.hist</a></code>,
populating it with the run's output data.</p>
<ul>
<li><code>vortons</code> default to equilateral triangle (<code><a title="vorts.vortons.Vortons.regular_polygon" href="vortons.html#vorts.vortons.Vortons.regular_polygon">Vortons.regular_polygon()</a></code> with <code>3, G=1</code>)</li>
<li><code>tracers</code> default to <code>None</code> (no tracers used)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/f26dc94d4ed5ba1d53a2199bbcef82fa9cd4cece/vorts/model.py#L23-L173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ModelBase(abc.ABC):
    &#34;&#34;&#34;Abstract base class for the models.

    Provides concrete methods `ModelBase.run` and `ModelBase.plot`, which work properly if the
    inheriting class defines a `_run` method that integrates the system and updates `ModelBase.hist`,
    populating it with the run&#39;s output data.
    &#34;&#34;&#34;

    def __init__(
        self,
        vortons: Vortons = None,
        tracers: Tracers = None,
        *,
        dt=0.1,
        nt=1000,
    ):
        &#34;&#34;&#34;
        * `vortons` default to equilateral triangle (`vorts.vortons.Vortons.regular_polygon` with `3, G=1`)
        * `tracers` default to `None` (no tracers used)
        &#34;&#34;&#34;
        # vortons (default to equilateral triangle)
        if vortons is None:
            vortons = Vortons.regular_polygon(3, G=1)
        self.vortons = vortons
        &#34;&#34;&#34;`vorts.vortons.Vortons` for the model instance.&#34;&#34;&#34;
        self.vortons0 = copy.deepcopy(vortons)  # store initial state (in hist as well)
        &#34;&#34;&#34;A copy of the initial `vorts.vortons.Vortons`, corresponding to the model input.&#34;&#34;&#34;

        # tracers (leave if `None`)
        self.tracers = tracers
        &#34;&#34;&#34;`vorts.vortons.Tracers` for the model instance, or `None` if no tracers.&#34;&#34;&#34;
        self.tracers0 = copy.deepcopy(self.tracers)
        &#34;&#34;&#34;A copy of the initial `vorts.vortons.Tracers` for the model instance, or `None` if no tracers.&#34;&#34;&#34;

        # sim settings/parameters for every model
        self.dt = float(dt)
        r&#34;&#34;&#34;Time step $\delta t$ for the model output.&#34;&#34;&#34;
        self.nt = int(nt)
        &#34;&#34;&#34;The number of time steps to run for, such that `t=nt*dt` is the last time simulated
        and we have a total of `nt+1` times when including the initial state.
        &#34;&#34;&#34;
        self.n_tracers = self.tracers0.n if self.tracers0 is not None else 0
        &#34;&#34;&#34;The number of tracers.&#34;&#34;&#34;
        self.n_vortons = self.vortons0.n
        &#34;&#34;&#34;The number of vortons (tracers not included!).&#34;&#34;&#34;
        self.n_points = self.n_vortons + self.n_tracers
        &#34;&#34;&#34;The number of vortons + tracers.&#34;&#34;&#34;
        self.n_timesteps = self.nt
        &#34;&#34;&#34;Alias for `ModelBase.nt`.&#34;&#34;&#34;

        # combine vortons and tracers (used by some models to feed combined initial states to integrators)
        self._vt0 = self.vortons0._maybe_add_tracers(self.tracers0)

        # initially no history
        self.hist = None
        &#34;&#34;&#34;An [`xr.Dataset`](http://xarray.pydata.org/en/stable/generated/xarray.Dataset.html)
        with coordinates `&#39;t&#39;` (time) and `&#39;v&#39;` (vorton index, including any tracers).
        Equal to `None` before the model has run.
        &#34;&#34;&#34;

        # initially, the model hasn&#39;t been run
        self._has_run = False

    @abc.abstractmethod
    def _run(self):
        &#34;&#34;&#34;The `_run` method in concrete classes should:

        1. Integrate the system from t=0 -&gt; t=(nt*dt).

        2. Update `hist`.
        &#34;&#34;&#34;
        ...

    def run(self):
        &#34;&#34;&#34;Integrate and update the history dataset `hist`.&#34;&#34;&#34;
        if self._has_run:
            warnings.warn(&#34;Note that the model has already been run.&#34;)
        self._run()
        self._has_run = True
        # TODO: with hist having been updated (presumably), update vortons?

        return self

    # might be better to use _plot_methods dict of name: function
    # so that certain models could extend the options
    def plot(self, which=&#34;vortons&#34;, **kwargs):
        &#34;&#34;&#34;Plot results stored in the history data set `hist`.

        `**kwargs` are passed through to the corresponding plotting function
        (see `vorts.plot`).
        &#34;&#34;&#34;
        if not self._has_run:
            raise Exception(&#34;The model has not yet been run.&#34;)

        if which == &#34;vortons&#34;:
            plot_vorton_trajectories(self.hist, **kwargs)
        elif which == &#34;tracers&#34;:
            plot_tracer_trajectories(self.hist, **kwargs)
        elif which == &#34;poincare&#34;:
            plot_poincare(self.hist, **kwargs)
        else:
            raise NotImplementedError(f&#34;which={which!r}&#34;)

    def _res_to_xr(self, xhist, yhist):
        &#34;&#34;&#34;Take full trajectory histories `xhist` and `yhist`
        in $(t, v)$ dim order and create a model results `xr.dataset`.
        &#34;&#34;&#34;
        vt0 = self._vt0

        G = vt0.G
        t = np.arange(0, self.nt + 1) * self.dt
        v = np.arange(0, vt0.n)

        is_t = G == 0

        ds = xr.Dataset(
            coords={
                &#34;t&#34;: (&#34;t&#34;, t, {&#34;long_name&#34;: &#34;Unitless elapsed time&#34;}),
                &#34;v&#34;: (
                    &#34;v&#34;,
                    v,
                    {
                        &#34;long_name&#34;: &#34;Vorton index&#34;,
                        &#34;description&#34;: (
                            r&#34;This includes true vortons (with nonzero $\Gamma$, coming first) &#34;
                            r&#34;and may also include tracers ($\Gamma = 0$, coming after).&#34;
                        ),
                    },
                ),
            },
            data_vars={
                &#34;G&#34;: ((&#34;v&#34;,), G, {&#34;long_name&#34;: r&#34;Vorton strength $\Gamma$ (circulation)&#34;}),
                &#34;x&#34;: ((&#34;t&#34;, &#34;v&#34;), xhist, {&#34;long_name&#34;: &#34;Vorton $x$ position&#34;}),
                &#34;y&#34;: ((&#34;t&#34;, &#34;v&#34;), yhist, {&#34;long_name&#34;: &#34;Vorton $y$ position&#34;}),
                &#34;is_t&#34;: (
                    (&#34;v&#34;,),
                    is_t,
                    {
                        &#34;long_name&#34;: &#34;Tracer mask&#34;,
                        &#34;description&#34;: (
                            r&#34;Vortons have nonzero $\Gamma$ values. Tracers have no $\Gamma$.&#34;
                        ),
                    },
                ),
            },
            attrs={
                &#34;model_class&#34;: self.__class__.__name__,
                &#34;int_scheme_name&#34;: getattr(self, &#34;int_scheme_name&#34;, &#34;?&#34;),
            },
        )
        return ds</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vorts.model.Model_f" href="#vorts.model.Model_f">Model_f</a></li>
<li><a title="vorts.model.Model_jl" href="#vorts.model.Model_jl">Model_jl</a></li>
<li><a title="vorts.model.Model_py" href="#vorts.model.Model_py">Model_py</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vorts.model.ModelBase.dt"><code class="name">var <span class="ident">dt</span></code></dt>
<dd>
<div class="desc"><p>Time step $\delta t$ for the model output.</p></div>
</dd>
<dt id="vorts.model.ModelBase.hist"><code class="name">var <span class="ident">hist</span></code></dt>
<dd>
<div class="desc"><p>An <a href="http://xarray.pydata.org/en/stable/generated/xarray.Dataset.html"><code>xr.Dataset</code></a>
with coordinates <code>'t'</code> (time) and <code>'v'</code> (vorton index, including any tracers).
Equal to <code>None</code> before the model has run.</p></div>
</dd>
<dt id="vorts.model.ModelBase.n_points"><code class="name">var <span class="ident">n_points</span></code></dt>
<dd>
<div class="desc"><p>The number of vortons + tracers.</p></div>
</dd>
<dt id="vorts.model.ModelBase.n_timesteps"><code class="name">var <span class="ident">n_timesteps</span></code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vorts.model.ModelBase.nt" href="#vorts.model.ModelBase.nt">ModelBase.nt</a></code>.</p></div>
</dd>
<dt id="vorts.model.ModelBase.n_tracers"><code class="name">var <span class="ident">n_tracers</span></code></dt>
<dd>
<div class="desc"><p>The number of tracers.</p></div>
</dd>
<dt id="vorts.model.ModelBase.n_vortons"><code class="name">var <span class="ident">n_vortons</span></code></dt>
<dd>
<div class="desc"><p>The number of vortons (tracers not included!).</p></div>
</dd>
<dt id="vorts.model.ModelBase.nt"><code class="name">var <span class="ident">nt</span></code></dt>
<dd>
<div class="desc"><p>The number of time steps to run for, such that <code>t=nt*dt</code> is the last time simulated
and we have a total of <code>nt+1</code> times when including the initial state.</p></div>
</dd>
<dt id="vorts.model.ModelBase.tracers"><code class="name">var <span class="ident">tracers</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vorts.vortons.Tracers" href="vortons.html#vorts.vortons.Tracers">Tracers</a></code> for the model instance, or <code>None</code> if no tracers.</p></div>
</dd>
<dt id="vorts.model.ModelBase.tracers0"><code class="name">var <span class="ident">tracers0</span></code></dt>
<dd>
<div class="desc"><p>A copy of the initial <code><a title="vorts.vortons.Tracers" href="vortons.html#vorts.vortons.Tracers">Tracers</a></code> for the model instance, or <code>None</code> if no tracers.</p></div>
</dd>
<dt id="vorts.model.ModelBase.vortons"><code class="name">var <span class="ident">vortons</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vorts.vortons.Vortons" href="vortons.html#vorts.vortons.Vortons">Vortons</a></code> for the model instance.</p></div>
</dd>
<dt id="vorts.model.ModelBase.vortons0"><code class="name">var <span class="ident">vortons0</span></code></dt>
<dd>
<div class="desc"><p>A copy of the initial <code><a title="vorts.vortons.Vortons" href="vortons.html#vorts.vortons.Vortons">Vortons</a></code>, corresponding to the model input.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vorts.model.ModelBase.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, which='vortons', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot results stored in the history data set <code>hist</code>.</p>
<p><code>**kwargs</code> are passed through to the corresponding plotting function
(see <code><a title="vorts.plot" href="plot.html">vorts.plot</a></code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/f26dc94d4ed5ba1d53a2199bbcef82fa9cd4cece/vorts/model.py#L108-L124" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot(self, which=&#34;vortons&#34;, **kwargs):
    &#34;&#34;&#34;Plot results stored in the history data set `hist`.

    `**kwargs` are passed through to the corresponding plotting function
    (see `vorts.plot`).
    &#34;&#34;&#34;
    if not self._has_run:
        raise Exception(&#34;The model has not yet been run.&#34;)

    if which == &#34;vortons&#34;:
        plot_vorton_trajectories(self.hist, **kwargs)
    elif which == &#34;tracers&#34;:
        plot_tracer_trajectories(self.hist, **kwargs)
    elif which == &#34;poincare&#34;:
        plot_poincare(self.hist, **kwargs)
    else:
        raise NotImplementedError(f&#34;which={which!r}&#34;)</code></pre>
</details>
</dd>
<dt id="vorts.model.ModelBase.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Integrate and update the history dataset <code>hist</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/f26dc94d4ed5ba1d53a2199bbcef82fa9cd4cece/vorts/model.py#L96-L104" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;Integrate and update the history dataset `hist`.&#34;&#34;&#34;
    if self._has_run:
        warnings.warn(&#34;Note that the model has already been run.&#34;)
    self._run()
    self._has_run = True
    # TODO: with hist having been updated (presumably), update vortons?

    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vorts.model.Model_f"><code class="flex name class">
<span>class <span class="ident">Model_f</span></span>
<span>(</span><span>vortons: <a title="vorts.vortons.Vortons" href="vortons.html#vorts.vortons.Vortons">Vortons</a> = None, tracers: <a title="vorts.vortons.Tracers" href="vortons.html#vorts.vortons.Tracers">Tracers</a> = None, *, dt=0.1, nt=1000, int_scheme_name='RK4', write_vortons=True, write_tracers=False, write_ps=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Thin wrapper for functionality of the Fortran model, whose source code is in <code>vorts/f/src/</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this implementation we communicate with the Fortran program via text files.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vortons</code></strong> :&ensp;<code><a title="vorts.vortons.Vortons" href="vortons.html#vorts.vortons.Vortons">Vortons</a></code></dt>
<dd>default: equilateral triangle with inscribing circle radius of $1$ and all $G=1$.</dd>
<dt><strong><code>tracers</code></strong> :&ensp;<code><a title="vorts.vortons.Tracers" href="vortons.html#vorts.vortons.Tracers">Tracers</a></code></dt>
<dd>default: no tracers</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time step $\delta t$ for the output.
Additionally, for the integrators, <code>dt</code> is used as the constant or maximum integration time step
depending on the integration scheme.</dd>
<dt><strong><code>nt</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of time steps to run (not including $t=0$).</dd>
<dt><strong><code>int_scheme_name</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Time integration scheme name.</p>
<p>options: <code>'RK4'</code> (standard RK4; default), <code>'FT'</code> (1st-order forward Euler)</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/f26dc94d4ed5ba1d53a2199bbcef82fa9cd4cece/vorts/model.py#L310-L485" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Model_f(ModelBase):
    &#34;&#34;&#34;Thin wrapper for functionality of the Fortran model, whose source code is in `vorts/f/src/`.

    .. note::
       In this implementation we communicate with the Fortran program via text files.
    &#34;&#34;&#34;

    # _allowed_int_scheme_names = (&#34;FT&#34;, &#34;RK4&#34;)

    def __init__(
        self,
        vortons: Vortons = None,
        tracers: Tracers = None,
        *,
        dt=0.1,
        nt=1000,
        # above are passed to base
        int_scheme_name=&#34;RK4&#34;,
        #
        write_vortons=True,  # maybe should put `flag` or something in these names
        write_tracers=False,
        write_ps=False,
    ):
        r&#34;&#34;&#34;

        Parameters
        ----------
        vortons : vorts.vortons.Vortons
            default: equilateral triangle with inscribing circle radius of $1$ and all $G=1$.

        tracers : vorts.vortons.Tracers
            default: no tracers

        dt : float
            Time step $\delta t$ for the output.
            Additionally, for the integrators, `dt` is used as the constant or maximum integration time step
            depending on the integration scheme.
        nt : int
            Number of time steps to run (not including $t=0$).

        int_scheme_name : str
            Time integration scheme name.

            options: `&#39;RK4&#39;` (standard RK4; default), `&#39;FT&#39;` (1st-order forward Euler)

        &#34;&#34;&#34;
        # call base initialization
        super().__init__(vortons, tracers, dt=dt, nt=nt)

        # other inputs
        self.int_scheme_name = int_scheme_name  # {&#39;FT&#39;, &#39;RK4&#39;}

        # output option flags
        self.f_write_out_vortons = write_vortons
        self.f_write_out_tracers = write_tracers
        self.f_write_out_ps = write_ps

        # executing the model
        assert (FORT_BASE_DIR / &#34;src&#34;).exists(), &#34;Fortran source directory not found!&#34;
        exe_name = &#34;vorts.exe&#34; if platform.system() == &#34;Windows&#34; else &#34;vorts&#34;
        self.vorts_exe_path = FORT_BASE_DIR / &#34;bin&#34; / exe_name
        self.oe = &#34;&#34;  # we will store standard output and error here

        # create the needed subdirs if they don&#39;t exist (pip install)
        for sub in (&#34;bin&#34;, &#34;in&#34;, &#34;out&#34;):
            p = FORT_BASE_DIR / sub
            if not p.exists():
                p.mkdir()

        # write the text input files to directory `vorts/f/in`
        self.create_inputs()

    def create_inputs(self):
        &#34;&#34;&#34;
        Create input files for the Fortran model
          describing the initial condition
          and the simulation settings.
        &#34;&#34;&#34;
        # # write vorton system initial state
        # mat = self.vortons0.state_mat_full()  # needs to be rows of G, xi, yi
        # np.savetxt(FORT_BASE_DIR / &#39;in/vorts_in.txt&#39;, mat,
        #            delimiter=&#39; &#39;, fmt=&#39;%.16f&#39;, header=&#39;Gamma xi yi&#39;)

        # # write tracers initial state (positions only)
        # mat = self.tracers0.state_mat
        # np.savetxt(FORT_BASE_DIR / &#39;in/tracers_in.txt&#39;, mat,
        #            delimiter=&#39; &#39;, fmt=&#39;%.16f&#39;, header=&#39;xi yi&#39;)

        # Write combined vortons + tracers, with vortons first
        mat = self._vt0.state_mat_full()
        np.savetxt(
            FORT_BASE_DIR / &#34;in/vortons.txt&#34;, mat, delimiter=&#34; &#34;, fmt=&#34;%.16f&#34;, header=&#34;Gamma xi yi&#34;
        )

        # write model options
        mat = [
            self.dt,
            self.nt,
            self.int_scheme_name,
            fort_bool(self.f_write_out_vortons),
            fort_bool(self.f_write_out_tracers),
            fort_bool(self.f_write_out_ps),
        ]
        np.savetxt(FORT_BASE_DIR / &#34;in/settings.txt&#34;, mat, delimiter=&#34; &#34;, fmt=&#34;%s&#34;)

    def _maybe_try_compile(self):
        &#34;&#34;&#34;Try to run `make` if the executable is missing.&#34;&#34;&#34;
        if not self.vorts_exe_path.exists():
            with _out_and_back(FORT_BASE_DIR / &#34;src&#34;):
                print(f&#34;{self.vorts_exe_path!r} doesn&#39;t exist, attempting to `make`.\n&#34;)
                try:
                    subprocess.run(&#34;make&#34;)
                except Exception as e:
                    raise Exception(
                        &#34;Attempted `make` failed with exception (see above). &#34;
                        &#34;The Fortran code must be compiled before running!&#34;
                    ) from e

    # implement abstract method `_run`
    def _run(self):
        &#34;&#34;&#34;Invoke the Fortran model&#39;s executable and load the results.&#34;&#34;&#34;
        self._maybe_try_compile()

        # Invoke the Fortran model&#39;s executable
        # Note: could instead pass FORT_BASE_DIR into the Fortran program so could run from anywhere
        cmd = str(self.vorts_exe_path.relative_to(FORT_BASE_DIR))
        with _out_and_back(FORT_BASE_DIR):
            for f in glob.glob(&#34;./out/*&#34;):  # non-hidden files
                os.remove(f)
            self.oe = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
            # Note: could instead use `error stop` in the Fortran to get non-zero exit code and `CalledProcessError`
            s_oe = str(self.oe, &#34;utf-8&#34;)
            if s_oe.startswith(&#34;STOP&#34;):
                raise Exception(f&#34;the model stopped early, with message:\n{str(s_oe)}&#34;)

        # Load results from the text file outputs into `self.hist` (an `xr.Dataset`)
        self._load_results()

    def _load_results(self):
        &#34;&#34;&#34;Load results from a run of the Fortran model.&#34;&#34;&#34;
        sf = 0  # there may be blank line at end of the files?

        nt = self.nt  # time steps taken
        nv = self._vt0.n
        G = self._vt0.G
        is_t = G == 0
        is_v = ~is_t

        # TODO: was trying avoid pre-allocating empty array, but for now gonna do it...
        self.hist = self._res_to_xr(np.empty((nt + 1, nv)), np.empty((nt + 1, nv)))

        if self.f_write_out_vortons:
            vortons_file = FORT_BASE_DIR / &#34;out/vortons.csv&#34;
            data = np.genfromtxt(vortons_file, delimiter=&#34;,&#34;, skip_header=1, skip_footer=sf)
            nrows = data.shape[0]
            i1 = np.arange(0, nrows - 1, 2)
            i2 = np.arange(1, nrows, 2)
            # need to swap dims because t is first in hist
            self.hist[&#34;x&#34;].loc[dict(v=is_v)] = data[i1, :].T
            self.hist[&#34;y&#34;].loc[dict(v=is_v)] = data[i2, :].T

        if self.f_write_out_tracers:
            tracers_file = FORT_BASE_DIR / &#34;out/tracers.csv&#34;
            data = np.genfromtxt(tracers_file, delimiter=&#34;,&#34;, skip_header=1, skip_footer=sf)
            nrows = data.shape[0]
            i1 = np.arange(0, nrows - 1, 2)
            i2 = np.arange(1, nrows, 2)
            self.hist[&#34;x&#34;].loc[dict(v=is_t)] = data[i1, :].T
            self.hist[&#34;y&#34;].loc[dict(v=is_t)] = data[i2, :].T

        # note: the ps code of the Fortran model only works for a specific case
        # (initial equi tri with the second point having x=0 and y&gt;0)
        if self.f_write_out_ps:
            ps_file = FORT_BASE_DIR / &#34;out/ps.txt&#34;
            data = np.genfromtxt(ps_file, skip_header=1, skip_footer=sf)
            self.ps = data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vorts.model.ModelBase" href="#vorts.model.ModelBase">ModelBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="vorts.model.Model_f.create_inputs"><code class="name flex">
<span>def <span class="ident">create_inputs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create input files for the Fortran model
describing the initial condition
and the simulation settings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/f26dc94d4ed5ba1d53a2199bbcef82fa9cd4cece/vorts/model.py#L382-L413" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def create_inputs(self):
    &#34;&#34;&#34;
    Create input files for the Fortran model
      describing the initial condition
      and the simulation settings.
    &#34;&#34;&#34;
    # # write vorton system initial state
    # mat = self.vortons0.state_mat_full()  # needs to be rows of G, xi, yi
    # np.savetxt(FORT_BASE_DIR / &#39;in/vorts_in.txt&#39;, mat,
    #            delimiter=&#39; &#39;, fmt=&#39;%.16f&#39;, header=&#39;Gamma xi yi&#39;)

    # # write tracers initial state (positions only)
    # mat = self.tracers0.state_mat
    # np.savetxt(FORT_BASE_DIR / &#39;in/tracers_in.txt&#39;, mat,
    #            delimiter=&#39; &#39;, fmt=&#39;%.16f&#39;, header=&#39;xi yi&#39;)

    # Write combined vortons + tracers, with vortons first
    mat = self._vt0.state_mat_full()
    np.savetxt(
        FORT_BASE_DIR / &#34;in/vortons.txt&#34;, mat, delimiter=&#34; &#34;, fmt=&#34;%.16f&#34;, header=&#34;Gamma xi yi&#34;
    )

    # write model options
    mat = [
        self.dt,
        self.nt,
        self.int_scheme_name,
        fort_bool(self.f_write_out_vortons),
        fort_bool(self.f_write_out_tracers),
        fort_bool(self.f_write_out_ps),
    ]
    np.savetxt(FORT_BASE_DIR / &#34;in/settings.txt&#34;, mat, delimiter=&#34; &#34;, fmt=&#34;%s&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vorts.model.ModelBase" href="#vorts.model.ModelBase">ModelBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vorts.model.ModelBase.dt" href="#vorts.model.ModelBase.dt">dt</a></code></li>
<li><code><a title="vorts.model.ModelBase.hist" href="#vorts.model.ModelBase.hist">hist</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_points" href="#vorts.model.ModelBase.n_points">n_points</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_timesteps" href="#vorts.model.ModelBase.n_timesteps">n_timesteps</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_tracers" href="#vorts.model.ModelBase.n_tracers">n_tracers</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_vortons" href="#vorts.model.ModelBase.n_vortons">n_vortons</a></code></li>
<li><code><a title="vorts.model.ModelBase.nt" href="#vorts.model.ModelBase.nt">nt</a></code></li>
<li><code><a title="vorts.model.ModelBase.plot" href="#vorts.model.ModelBase.plot">plot</a></code></li>
<li><code><a title="vorts.model.ModelBase.run" href="#vorts.model.ModelBase.run">run</a></code></li>
<li><code><a title="vorts.model.ModelBase.tracers" href="#vorts.model.ModelBase.tracers">tracers</a></code></li>
<li><code><a title="vorts.model.ModelBase.tracers0" href="#vorts.model.ModelBase.tracers0">tracers0</a></code></li>
<li><code><a title="vorts.model.ModelBase.vortons" href="#vorts.model.ModelBase.vortons">vortons</a></code></li>
<li><code><a title="vorts.model.ModelBase.vortons0" href="#vorts.model.ModelBase.vortons0">vortons0</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vorts.model.Model_jl"><code class="flex name class">
<span>class <span class="ident">Model_jl</span></span>
<span>(</span><span>vortons: <a title="vorts.vortons.Vortons" href="vortons.html#vorts.vortons.Vortons">Vortons</a> = None, tracers: <a title="vorts.vortons.Tracers" href="vortons.html#vorts.vortons.Tracers">Tracers</a> = None, *, dt=0.1, nt=1000, int_scheme_name='Tsit5', use_sysimage=False, run_method='pyjulia')</span>
</code></dt>
<dd>
<div class="desc"><p>Interface to the Julia model, whose source code is in <code>vorts/jl/vorts.jl</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this implementation we communicate with Julia using
<a href="https://github.com/JuliaPy/pyjulia">pyjulia</a></p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vortons</code></strong> :&ensp;<code><a title="vorts.vortons.Vortons" href="vortons.html#vorts.vortons.Vortons">Vortons</a></code></dt>
<dd>default: equilateral triangle with inscribing circle radius of $1$ and all $G=1$.</dd>
<dt><strong><code>tracers</code></strong> :&ensp;<code><a title="vorts.vortons.Tracers" href="vortons.html#vorts.vortons.Tracers">Tracers</a></code></dt>
<dd>default: no tracers</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time step $\delta t$ for the output.
Additionally, for the integrators, <code>dt</code> is used as the constant or maximum integration time step
depending on the integration scheme.</dd>
<dt><strong><code>nt</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of time steps to run (not including $t=0$).</dd>
<dt><strong><code>int_scheme_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Time integration scheme name. Any from the
<a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/">ODE solvers list</a>
are valid.</dd>
<dt><strong><code>use_sysimage</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to (try to) use the <code>sys_vorts.so</code> created by the <code>compile.jl</code> script.</dd>
<dt><strong><code>run_method</code></strong> :&ensp;<code>str, {'pyjulia', 'diffeqpy'}</code></dt>
<dd>Currently, we can run using pyjulia alone or using diffeqpy.
Both use the tendency function defined in <code>vorts.jl</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/f26dc94d4ed5ba1d53a2199bbcef82fa9cd4cece/vorts/model.py#L491-L645" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Model_jl(ModelBase):
    &#34;&#34;&#34;Interface to the Julia model, whose source code is in `vorts/jl/vorts.jl`.

    .. note::
       In this implementation we communicate with Julia using
       [pyjulia](https://github.com/JuliaPy/pyjulia)
    &#34;&#34;&#34;

    def __init__(
        self,
        vortons: Vortons = None,
        tracers: Tracers = None,
        *,
        dt=0.1,
        nt=1000,
        # above are passed to base
        int_scheme_name=&#34;Tsit5&#34;,
        use_sysimage=False,
        run_method=&#34;pyjulia&#34;,
    ):
        r&#34;&#34;&#34;

        Parameters
        ----------
        vortons : vorts.vortons.Vortons
            default: equilateral triangle with inscribing circle radius of $1$ and all $G=1$.

        tracers : vorts.vortons.Tracers
            default: no tracers

        dt : float
            Time step $\delta t$ for the output.
            Additionally, for the integrators, `dt` is used as the constant or maximum integration time step
            depending on the integration scheme.
        nt : int
            Number of time steps to run (not including $t=0$).

        int_scheme_name : str
            Time integration scheme name. Any from the
            [ODE solvers list](https://diffeq.sciml.ai/stable/solvers/ode_solve/)
            are valid.
        use_sysimage : bool
            Whether to (try to) use the `sys_vorts.so` created by the `compile.jl` script.
        run_method : str, {&#39;pyjulia&#39;, &#39;diffeqpy&#39;}
            Currently, we can run using pyjulia alone or using diffeqpy.
            Both use the tendency function defined in `vorts.jl`.
        &#34;&#34;&#34;
        # Call base initialization
        super().__init__(vortons, tracers, dt=dt, nt=nt)

        # Other inputs
        self.int_scheme_name = int_scheme_name
        self.use_sysimage = use_sysimage
        self.run_method = run_method

    @staticmethod
    def _load_jl_sysimage():
        # Use our sysimage with DifferentialEquations (and our tend fn) pre-compiled
        # (has to be done before importing any Julia modules)
        from julia import Julia

        jl = Julia(sysimage=str(JL_BASE_DIR / &#34;sys_vorts.so&#34;))
        # TODO: might want to also support `Julia(compiled_modules=False)` in some way
        return jl

    # pyjulia alone
    def _run_pyjulia(self):
        from julia.core import JuliaError

        if self.use_sysimage:
            self._load_jl_sysimage()

        # For some reason it doesn&#39;t work the first time on Windows (can&#39;t find PyCall)
        # but will work if we just do it again...
        try:
            from julia import Base, Main, Pkg
        except JuliaError as e:
            warnings.warn(f&#34;Julia imports failed the first time with message:\n{e}&#34;)
            from julia import Base, Main, Pkg

        # Load our code
        # Base.println(&#34;Initial env status:&#34;)
        # Pkg.status()
        Pkg.activate(JL_BASE_DIR.as_posix())
        Pkg.status()
        Main.include((JL_BASE_DIR / &#34;vorts.jl&#34;).as_posix())
        Base.println(&#34;vorts.jl has been loaded!&#34;)

        # Run by calling `integrate` from `vorts.jl`
        x, y = Main.integrate(
            self._vt0.state_mat,
            self._vt0.G,
            self.dt,
            self.nt,
            int_scheme_name=self.int_scheme_name,
            ret_for=&#34;python&#34;,
        )

        # Set output dataset
        self.hist = self._res_to_xr(x, y)

    # pyjulia + diffeqpy
    def _run_diffeqpy(self):
        from julia.core import JuliaError

        if self.use_sysimage:
            self._load_jl_sysimage()

        try:
            from julia import Base, Main, Pkg
        except JuliaError as e:
            warnings.warn(f&#34;Julia imports failed the first time with message:\n{e}&#34;)
            from julia import Base, Main, Pkg

        Pkg.activate(JL_BASE_DIR.as_posix())
        Pkg.status()

        # `ode` from the readme doesn&#39;t work yet in stable (would have to install from GH)
        # This one would also take two tries in Win if we hadn&#39;t already done the above import
        from diffeqpy import de

        # Add the code with the tendency function
        Main.include((JL_BASE_DIR / &#34;vorts.jl&#34;).as_posix())
        Base.println(&#34;vorts.jl has been loaded!&#34;)

        # Set up our inputs
        nt = self.nt
        dt = self.dt
        vt0 = self._vt0
        r0 = vt0.state_mat.T  # note transpose!
        tspan = (0, dt * nt)
        p = Main.TendParams(vt0.G)
        solver = getattr(de, self.int_scheme_name)()

        prob = de.ODEProblem(Main.tend_b, r0, tspan, p)
        sol = de.solve(prob, solver, saveat=np.arange(0, nt + 1) * dt)

        # Exract data and set the output dataset
        x = np.empty((self.nt + 1, vt0.n))
        y = np.empty_like(x)
        assert len(sol.u) == nt + 1
        assert sol.u[0].shape == (2, vt0.n)
        for i in range(len(sol.u)):
            x[i, :] = sol.u[i][0, :]
            y[i, :] = sol.u[i][1, :]

        self.hist = self._res_to_xr(x, y)

    def _run(self):
        if self.run_method == &#34;pyjulia&#34;:
            self._run_pyjulia()
        elif self.run_method == &#34;diffeqpy&#34;:
            self._run_diffeqpy()
        else:
            raise ValueError(&#34;`run_method` must be &#39;pyjulia&#39; or &#39;diffeqpy&#39;.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vorts.model.ModelBase" href="#vorts.model.ModelBase">ModelBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vorts.model.ModelBase" href="#vorts.model.ModelBase">ModelBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vorts.model.ModelBase.dt" href="#vorts.model.ModelBase.dt">dt</a></code></li>
<li><code><a title="vorts.model.ModelBase.hist" href="#vorts.model.ModelBase.hist">hist</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_points" href="#vorts.model.ModelBase.n_points">n_points</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_timesteps" href="#vorts.model.ModelBase.n_timesteps">n_timesteps</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_tracers" href="#vorts.model.ModelBase.n_tracers">n_tracers</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_vortons" href="#vorts.model.ModelBase.n_vortons">n_vortons</a></code></li>
<li><code><a title="vorts.model.ModelBase.nt" href="#vorts.model.ModelBase.nt">nt</a></code></li>
<li><code><a title="vorts.model.ModelBase.plot" href="#vorts.model.ModelBase.plot">plot</a></code></li>
<li><code><a title="vorts.model.ModelBase.run" href="#vorts.model.ModelBase.run">run</a></code></li>
<li><code><a title="vorts.model.ModelBase.tracers" href="#vorts.model.ModelBase.tracers">tracers</a></code></li>
<li><code><a title="vorts.model.ModelBase.tracers0" href="#vorts.model.ModelBase.tracers0">tracers0</a></code></li>
<li><code><a title="vorts.model.ModelBase.vortons" href="#vorts.model.ModelBase.vortons">vortons</a></code></li>
<li><code><a title="vorts.model.ModelBase.vortons0" href="#vorts.model.ModelBase.vortons0">vortons0</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vorts.model.Model_py"><code class="flex name class">
<span>class <span class="ident">Model_py</span></span>
<span>(</span><span>vortons: <a title="vorts.vortons.Vortons" href="vortons.html#vorts.vortons.Vortons">Vortons</a> = None, tracers: <a title="vorts.vortons.Tracers" href="vortons.html#vorts.vortons.Tracers">Tracers</a> = None, *, dt=0.1, nt=1000, int_scheme_name='RK4', **int_scheme_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Model in Python.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vortons</code></strong> :&ensp;<code><a title="vorts.vortons.Vortons" href="vortons.html#vorts.vortons.Vortons">Vortons</a></code></dt>
<dd>default: equilateral triangle with inscribing circle radius of $1$ and all $G=1$.</dd>
<dt><strong><code>tracers</code></strong> :&ensp;<code><a title="vorts.vortons.Tracers" href="vortons.html#vorts.vortons.Tracers">Tracers</a></code></dt>
<dd>default: no tracers</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time step $\delta t$ for the output.
Additionally, for the integrators, <code>dt</code> is used as the constant or maximum integration time step
depending on the integration scheme.</dd>
<dt><strong><code>nt</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of time steps to run (not including $t=0$).</dd>
<dt><strong><code>int_scheme_name</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Time integration scheme name.</p>
<p>default: <code>'RK4'</code> &ndash; handwritten standard RK4, using Numba to calculate the tendencies</p>
<p>Other currently valid options are:</p>
<ul>
<li>
<p><code>'scipy_*'</code> methods &ndash; use <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html"><code>scipy.integrate.solve_ivp</code></a></p>
<p>where the <code>*</code> can be <code>RK45</code>, <code>DOP854</code>, <code>Radau</code>, <code>BDF</code>, <code>LSODA</code></p>
</li>
<li>
<p><code>'FT'</code> &ndash; handwritten 1st-order forward Euler</p>
</li>
</ul>
</dd>
<dt><strong><code>**int_scheme_kwargs</code></strong></dt>
<dd>Passed on to <code><a title="vorts.py.integ.integrate_manual" href="py/integ.html#vorts.py.integ.integrate_manual">integrate_manual()</a></code> or <code><a title="vorts.py.integ.integrate_scipy" href="py/integ.html#vorts.py.integ.integrate_scipy">integrate_scipy()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/f26dc94d4ed5ba1d53a2199bbcef82fa9cd4cece/vorts/model.py#L176-L286" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Model_py(ModelBase):
    &#34;&#34;&#34;Model in Python.&#34;&#34;&#34;

    _manual_steppers = MANUAL_STEPPERS
    _scipy_methods = SCIPY_METHODS
    _allowed_int_scheme_names = list(_manual_steppers) + list(_scipy_methods)
    # _allowed_int_scheme_names = list(_scipy_methods)  # temporarily disable manual steppers methods

    def __init__(
        self,
        vortons: Vortons = None,
        tracers: Tracers = None,
        *,
        dt=0.1,
        nt=1000,
        # above are passed to base
        int_scheme_name=&#34;RK4&#34;,
        **int_scheme_kwargs,
    ):
        r&#34;&#34;&#34;

        Parameters
        ----------
        vortons : vorts.vortons.Vortons
            default: equilateral triangle with inscribing circle radius of $1$ and all $G=1$.

        tracers : vorts.vortons.Tracers
            default: no tracers

        dt : float
            Time step $\delta t$ for the output.
            Additionally, for the integrators, `dt` is used as the constant or maximum integration time step
            depending on the integration scheme.
        nt : int
            Number of time steps to run (not including $t=0$).

        int_scheme_name : str
            Time integration scheme name.

            default: `&#39;RK4&#39;` -- handwritten standard RK4, using Numba to calculate the tendencies

            Other currently valid options are:

            * `&#39;scipy_*&#39;` methods -- use [`scipy.integrate.solve_ivp`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html)

                where the `*` can be `RK45`, `DOP854`, `Radau`, `BDF`, `LSODA`

            * `&#39;FT&#39;` -- handwritten 1st-order forward Euler

        **int_scheme_kwargs
            Passed on to `vorts.py.integ.integrate_manual` or `vorts.py.integ.integrate_scipy`.

        &#34;&#34;&#34;
        # call base initialization
        super().__init__(vortons, tracers, dt=dt, nt=nt)

        # other inputs
        self.int_scheme_name = int_scheme_name
        self.int_scheme_kwargs = int_scheme_kwargs

        # check `int_scheme_name`
        if self.int_scheme_name not in self._allowed_int_scheme_names:
            raise ValueError(
                f&#34;{self.int_scheme_name!r} is not one of the allowed options for `int_scheme_name`:\n&#34;
                f&#34;{self._allowed_int_scheme_names}&#34;
            )

        # calculate initial C, used for adaptive time stepping tolerance checks
        self.C_0 = self.vortons0.C()

    # implement abstract method `_run`
    def _run(self):
        dt, nt = self.dt, self.nt
        # t_eval = np.arange(dt, (nt+1)*dt, dt)
        t_eval = np.arange(0, nt + 1) * dt
        v0 = self._vt0

        # manual (handwritten) integrators
        if &#34;scipy&#34; not in self.int_scheme_name:
            x0 = v0.x
            y0 = v0.y
            G = v0.G
            xhist, yhist = integrate_manual(
                G,
                x0,
                y0,
                #
                self.C_0,
                t_eval,
                stepper=self._manual_steppers[self.int_scheme_name],
                **self.int_scheme_kwargs,
            )
            # returned data have shape (nv, nt)
            self.hist = self._res_to_xr(xhist.T, yhist.T)

        # integration using SciPy
        else:
            y0 = v0.xy.T.flatten()  # needs to be a 1-d array!
            G_col = v0.G_col
            data = integrate_scipy(
                y0,
                t_eval,
                G_col,
                #
                method=self._scipy_methods[self.int_scheme_name],
                max_step=dt,
                **self.int_scheme_kwargs,
            )
            # returned data has shape (2nv, nt), where n is number of vortons and nt number of time steps
            nv = v0.n
            self.hist = self._res_to_xr(data[:nv, :].T, data[nv:, :].T)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vorts.model.ModelBase" href="#vorts.model.ModelBase">ModelBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vorts.model.ModelBase" href="#vorts.model.ModelBase">ModelBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vorts.model.ModelBase.dt" href="#vorts.model.ModelBase.dt">dt</a></code></li>
<li><code><a title="vorts.model.ModelBase.hist" href="#vorts.model.ModelBase.hist">hist</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_points" href="#vorts.model.ModelBase.n_points">n_points</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_timesteps" href="#vorts.model.ModelBase.n_timesteps">n_timesteps</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_tracers" href="#vorts.model.ModelBase.n_tracers">n_tracers</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_vortons" href="#vorts.model.ModelBase.n_vortons">n_vortons</a></code></li>
<li><code><a title="vorts.model.ModelBase.nt" href="#vorts.model.ModelBase.nt">nt</a></code></li>
<li><code><a title="vorts.model.ModelBase.plot" href="#vorts.model.ModelBase.plot">plot</a></code></li>
<li><code><a title="vorts.model.ModelBase.run" href="#vorts.model.ModelBase.run">run</a></code></li>
<li><code><a title="vorts.model.ModelBase.tracers" href="#vorts.model.ModelBase.tracers">tracers</a></code></li>
<li><code><a title="vorts.model.ModelBase.tracers0" href="#vorts.model.ModelBase.tracers0">tracers0</a></code></li>
<li><code><a title="vorts.model.ModelBase.vortons" href="#vorts.model.ModelBase.vortons">vortons</a></code></li>
<li><code><a title="vorts.model.ModelBase.vortons0" href="#vorts.model.ModelBase.vortons0">vortons0</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<h1 style="margin-top: -16px;">
<a class="homelink" rel="home" title="vorts Home" href="https://zmoon.github.io/vorts/">
vorts
</a>
</h1>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vorts" href="index.html">vorts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vorts.model.fort_bool" href="#vorts.model.fort_bool">fort_bool</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vorts.model.ModelBase" href="#vorts.model.ModelBase">ModelBase</a></code></h4>
<ul class="two-column">
<li><code><a title="vorts.model.ModelBase.dt" href="#vorts.model.ModelBase.dt">dt</a></code></li>
<li><code><a title="vorts.model.ModelBase.hist" href="#vorts.model.ModelBase.hist">hist</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_points" href="#vorts.model.ModelBase.n_points">n_points</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_timesteps" href="#vorts.model.ModelBase.n_timesteps">n_timesteps</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_tracers" href="#vorts.model.ModelBase.n_tracers">n_tracers</a></code></li>
<li><code><a title="vorts.model.ModelBase.n_vortons" href="#vorts.model.ModelBase.n_vortons">n_vortons</a></code></li>
<li><code><a title="vorts.model.ModelBase.nt" href="#vorts.model.ModelBase.nt">nt</a></code></li>
<li><code><a title="vorts.model.ModelBase.plot" href="#vorts.model.ModelBase.plot">plot</a></code></li>
<li><code><a title="vorts.model.ModelBase.run" href="#vorts.model.ModelBase.run">run</a></code></li>
<li><code><a title="vorts.model.ModelBase.tracers" href="#vorts.model.ModelBase.tracers">tracers</a></code></li>
<li><code><a title="vorts.model.ModelBase.tracers0" href="#vorts.model.ModelBase.tracers0">tracers0</a></code></li>
<li><code><a title="vorts.model.ModelBase.vortons" href="#vorts.model.ModelBase.vortons">vortons</a></code></li>
<li><code><a title="vorts.model.ModelBase.vortons0" href="#vorts.model.ModelBase.vortons0">vortons0</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vorts.model.Model_f" href="#vorts.model.Model_f">Model_f</a></code></h4>
<ul class="">
<li><code><a title="vorts.model.Model_f.create_inputs" href="#vorts.model.Model_f.create_inputs">create_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vorts.model.Model_jl" href="#vorts.model.Model_jl">Model_jl</a></code></h4>
</li>
<li>
<h4><code><a title="vorts.model.Model_py" href="#vorts.model.Model_py">Model_py</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<span style="color:#777777">&copy; Z. Moon 2020</span>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>